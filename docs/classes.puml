
@startuml "Matching Engine Library"
!theme plain
skinparam backgroundColor #FAFAFA
skinparam classBackgroundColor #E1F5FF
skinparam classBorderColor #0277BD

package "orderbook::core" <<core>> #FFFFFF {
    class MatchingEngine {
        -clock: IClock&
        -books: map<Symbol, OrderBook>
        -tradeRepository: ITradeRepository&
        -orderToSymbol: map<OrderId, Symbol>
        --
        +MatchingEngine(clock: IClock&, repo: ITradeRepository&)
        +new_order(req: NewOrderRequest): OrderId
        +cancel_order(orderId: OrderId): bool
        +modify_order(orderId: OrderId, req: ModifyOrderRequest): bool
        +get_or_create_book(symbol: Symbol): OrderBook&
        +get_symbol_by_order(orderId: OrderId): Symbol
    }

    class OrderBook {
        -bids: OrderBookSide
        -asks: OrderBookSide
        -orders: map<OrderId, Order>
        --
        +OrderBook()
        +submit_order(order: Order&): vector<Trade>
        +cancel_order(orderId: OrderId): bool
        +modify_order(orderId: OrderId, req: ModifyOrderRequest): bool
        +getBids(): map<Price, PriceLevel>&
        +getAsks(): map<Price, PriceLevel>&
    }

    class OrderBookSide {
        -side: Side
        -levels: map<Price, PriceLevel>
        --
        +OrderBookSide(side: Side)
        +add_order(order: Order*)
        +match(incoming: Order&, trades: vector<Trade>&): void
        +available_quantity_for_order(incoming: Order&): Quantity
        +remove_order(orderId: OrderId): bool
        -best_level_it(): iterator
    }

    class PriceLevel {
        -price: Price
        -orders: deque<Order*>
        --
        +PriceLevel(price: Price = 0.0)
        +add_order(o: Order*)
        +top_order(): Order*
        +remove_top_order(): void
        +price(): Price
        +is_empty(): bool
    }

    class Order {
        +orderId: OrderId
        +symbol: Symbol
        +side: Side
        +type: OrderType
        +tif: TimeInForce
        +price: Price
        +qty: Quantity
        +remaining: Quantity
        +filled: Quantity
        +timestamp: Timestamp
        --
        +add_fill(q: Quantity): void
    }

    class Trade {
        +tradeId: TradeId
        +symbol: Symbol
        +buyOrderId: OrderId
        +sellOrderId: OrderId
        +price: Price
        +quantity: Quantity
        +timestamp: Timestamp
    }
}

package "orderbook::report" <<report>> #FFFACD {
    interface ITradeRepository {
        {abstract} +add_trades(trades: vector<Trade>&): void
        {abstract} +trades_between(start: Timestamp, end: Timestamp): vector<Trade>
        {abstract} +trades_all(): vector<Trade>
    }

    class InternalTradeRepository {
        -allTrades: vector<Trade>
        -tradesBySymbol: map<Symbol, vector<Trade>>
        --
        +add_trades(trades: vector<Trade>&): void
        +trades_between(start: Timestamp, end: Timestamp): vector<Trade>
        +trades_all(): vector<Trade>
    }

    class FileTradeRepository {
        -filePath: string
        --
        +add_trades(trades: vector<Trade>&): void
        +trades_between(start: Timestamp, end: Timestamp): vector<Trade>
        +trades_all(): vector<Trade>
    }

    class ReportService {
        -repository: ITradeRepository&
        --
        +ReportService(repo: ITradeRepository&)
        +volume_all(symbol: Symbol): VolumeReport
        +volume_between(start: Timestamp, end: Timestamp): VolumeReport
        +price_all(symbol: Symbol): PriceStatsReport
        +price_between(start: Timestamp, end: Timestamp): PriceStatsReport
    }

    class VolumeReport {
        -data: VolumeStats
        --
        +VolumeReport(stats: VolumeStats)
        +stats(): const VolumeStats&
    }

    class VolumeStats {
        +symbol: Symbol
        +totalQuantity: Quantity
        +tradeCount: int
        --
        +isValid(): bool
    }

    class PriceStatsReport {
        -data: PriceStats
        --
        +PriceStatsReport(stats: PriceStats)
        +stats(): const PriceStats&
    }

    class PriceStats {
        +symbol: Symbol
        +minPrice: Price
        +maxPrice: Price
        +avgPrice: Price
        +stdDevPct: double
        +tradeCount: int
        --
        +isValid(): bool
    }
}

package "orderbook::util" <<util>> #F0F0F0 {
    abstract class IClock {
        {abstract} +now(): Timestamp
    }

    class SimulatedClock {
        -currentTime: Timestamp
        --
        +now(): Timestamp
        +advance(duration: Milliseconds): void
    }

    class SystemClock {
        +now(): Timestamp
    }

    class IdGenerator {
        -counter: uint64_t
        --
        +IdGenerator(start: uint64_t = 1)
        +next(): uint64_t
    }

    class Timestamp {
        +milliseconds: int64_t
        --
        +Timestamp(ms: int64_t = 0)
        +format(): string
        +operator<(other: Timestamp): bool
    }
}

package "orderbook::api" <<api>> #F3E5F5 {
    class NewOrderRequest {
        +symbol: Symbol
        +side: Side
        +type: OrderType
        +tif: TimeInForce
        +price: Price
        +quantity: Quantity
    }

    class ModifyOrderRequest {
        +hasNewQuantity: bool
        +newQuantity: Quantity
        +hasNewPrice: bool
        +newPrice: Price
    }
}

' ===== Relationships =====

' Inheritance
InternalTradeRepository --|> ITradeRepository : implements
FileTradeRepository --|> ITradeRepository : implements
SimulatedClock --|> IClock : implements
SystemClock --|> IClock : implements

' Composition
MatchingEngine --> OrderBook : manages per-symbol\n(map<Symbol, OrderBook>)
OrderBook --> OrderBookSide : contains\nbids & asks
OrderBookSide --> PriceLevel : maintains\nmap<Price, Level>
PriceLevel --> Order : queues FIFO\n(deque<Order*>)

' Dependencies
MatchingEngine ..> NewOrderRequest : uses
MatchingEngine ..> ModifyOrderRequest : uses
MatchingEngine ..> IClock : uses\n(get_time)
MatchingEngine ..> ITradeRepository : uses\n(record_trades)

OrderBook --> Trade : generates

ReportService ..> ITradeRepository : queries
ReportService --> VolumeReport : produces
ReportService --> PriceStatsReport : produces
VolumeReport --> VolumeStats : wraps
PriceStatsReport --> PriceStats : wraps

' ===== Notes =====

note right of MatchingEngine
  **Core Matching Engine**
  
  Per-symbol order books
  Multi-order simultaneous processing
  
  Order Type Handling:
  • FOK: Pre-check liquidity via
    available_quantity_for_order()
    If insufficient, kill (no trades)
  • IOC: Match immediately
    Remaining NOT placed in book
  • Market + GTC: Coerced to IOC
end note

note right of OrderBook
  **Per-Symbol Orderbook**
  
  Maintains separate bid/ask sides
  Implements matching logic
  Tracks all active orders
  Returns list of Trade objects
end note

note right of OrderBookSide
  **Price Level Management**
  
  FIFO queue per price point
  Best-price-first matching
  Supports partial fills
  Efficient price lookup
end note

note right of PriceLevel
  **FIFO Order Queue**
  
  Orders execute FIFO at same price
  Fair execution guarantee
  Deque-based implementation
end note

note right of ReportService
  **Statistics Calculation**
  
  Queries trade repository
  Calculates aggregates per symbol:
  
  Volume: Sum of quantities
  Price: Min, max, avg, std dev
  
  Supports time-range queries
end note

note right of ITradeRepository
  **Trade Storage Interface**
  
  Abstraction over storage backend
  Supports in-memory and file-based
  Time-range queries
  Full trade history access
end note

@enduml
